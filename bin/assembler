#!/usr/bin/env ruby

require_relative '../lib/parser'
require_relative '../lib/code'
require_relative '../lib/symbol_table'

Program = Struct.new(:source) do
  def each_instruction(&block)
    each_command do |command|
      command.each_instruction &block
    end
  end

  private

  def each_command
    parser = Parser.new(source)

    while parser.has_more_commands?
      parser.advance
      yield current_command(parser)
    end
  end

  def current_command(parser)
    case parser.command_type
    when Parser::A_COMMAND
      Command::Addressing.new(parser.symbol)
    when Parser::C_COMMAND
      Command::Compute.new(parser.dest, parser.comp, parser.jump)
    when Parser::L_COMMAND
      Command::Label.new(parser.symbol)
    end
  end
end

module Command
  RADIX = 10

  Addressing = Struct.new(:symbol) do
    def each_instruction
      yield Instruction::Addressing.new(value)
    end

    private

    def value
      if numeric?
        symbol.to_i(RADIX)
      else
        # TODO handle symbols
        raise 'canâ€™t handle symbols yet'
      end
    end

    def numeric?
      Integer(symbol, RADIX) rescue false
    end
  end

  Compute = Struct.new(:dest, :comp, :jump) do
    def each_instruction
      yield Instruction::Compute.new(dest, comp, jump)
    end
  end

  Label = Struct.new(:symbol) do
    def each_instruction
      # do nothing
    end
  end
end

module Instruction
  BIT_COUNT = 16
  ADDRESSING_BIT = '0'
  COMPUTE_BIT = '1'

  Addressing = Struct.new(:value) do
    def assemble
      value.to_s(2).rjust(BIT_COUNT, ADDRESSING_BIT)
    end
  end

  Compute = Struct.new(:dest, :comp, :jump) do
    def assemble
      [Code.comp(comp), Code.dest(dest), Code.jump(jump)].join.rjust(BIT_COUNT, COMPUTE_BIT)
    end
  end
end

Program.new(ARGF.read).each_instruction do |instruction|
  puts instruction.assemble
end
