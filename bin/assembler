#!/usr/bin/env ruby

require_relative '../lib/parser'
require_relative '../lib/code'
require_relative '../lib/symbol_table'

Program = Struct.new(:source) do
  def each_instruction(&block)
    symbol_table = Symbols.build_table(commands)

    each_command do |command|
      command.each_instruction symbol_table, &block
    end
  end

  private

  def commands
    enum_for :each_command
  end

  def each_command
    parser = Parser.new(source)

    while parser.has_more_commands?
      parser.advance
      yield current_command(parser)
    end
  end

  def current_command(parser)
    case parser.command_type
    when Parser::A_COMMAND
      Command::Addressing.new(parser.symbol)
    when Parser::C_COMMAND
      Command::Compute.new(parser.dest, parser.comp, parser.jump)
    when Parser::L_COMMAND
      Command::Label.new(parser.symbol)
    end
  end
end

module Symbols
  PREDEFINED_SYMBOLS = {
    'SP'      => 0x0000,
    'LCL'     => 0x0001,
    'ARG'     => 0x0002,
    'THIS'    => 0x0003,
    'THAT'    => 0x0004,
    'SCREEN'  => 0x4000,
    'KBD'     => 0x6000
  }
  REGISTER_PREFIX = 'R'
  REGISTER_COUNT = 16

  module_function

  def build_table(commands)
    SymbolTable.new.tap do |symbol_table|
      each_entry(commands) do |entry|
        symbol_table.add_entry entry.symbol, entry.address
      end
    end
  end

  def each_entry(commands, &block)
    each_predefined_symbol &block
    each_label commands, &block
  end

  def each_predefined_symbol
    PREDEFINED_SYMBOLS.each do |symbol, address|
      yield Entry.new(symbol, address)
    end

    REGISTER_COUNT.times do |n|
      yield Entry.new([REGISTER_PREFIX, n].join, n)
    end
  end

  def each_label(commands, &block)
    instruction_addresses = 0.upto(Float::INFINITY)

    commands.each do |command|
      command.each_label instruction_addresses, &block
    end
  end
end

Entry = Struct.new(:symbol, :address)

module Command
  RADIX = 10

  Addressing = Struct.new(:symbol) do
    def each_instruction(symbol_table)
      yield Instruction::Addressing.new(value(symbol_table))
    end

    def each_label(instruction_addresses)
      instruction_addresses.next
    end

    private

    def value(symbol_table)
      if numeric?
        symbol.to_i(RADIX)
      else
        # TODO handle variables
        raise "unknown symbol “#{symbol}”" unless symbol_table.contains?(symbol)
        symbol_table.get_address(symbol)
      end
    end

    def numeric?
      Integer(symbol, RADIX) rescue false
    end
  end

  Compute = Struct.new(:dest, :comp, :jump) do
    def each_instruction(symbol_table)
      yield Instruction::Compute.new(dest, comp, jump)
    end

    def each_label(instruction_addresses)
      instruction_addresses.next
    end
  end

  Label = Struct.new(:symbol) do
    def each_instruction(symbol_table)
      # do nothing
    end

    def each_label(instruction_addresses)
      yield Entry.new(symbol, instruction_addresses.peek)
    end
  end
end

module Instruction
  BIT_COUNT = 16
  ADDRESSING_BIT = '0'
  COMPUTE_BIT = '1'

  Addressing = Struct.new(:value) do
    def assemble
      value.to_s(2).rjust(BIT_COUNT, ADDRESSING_BIT)
    end
  end

  Compute = Struct.new(:dest, :comp, :jump) do
    def assemble
      [Code.comp(comp), Code.dest(dest), Code.jump(jump)].join.rjust(BIT_COUNT, COMPUTE_BIT)
    end
  end
end

Program.new(ARGF.read).each_instruction do |instruction|
  puts instruction.assemble
end
