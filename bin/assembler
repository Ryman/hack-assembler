#!/usr/bin/env ruby

require_relative '../lib/parser'
require_relative '../lib/code'
require_relative '../lib/symbol_table'

Program = Struct.new(:source) do
  def each_instruction(&block)
    symbol_table = Symbols.build_table

    each_command do |command|
      command.each_instruction symbol_table, &block
    end
  end

  private

  def each_command
    parser = Parser.new(source)

    while parser.has_more_commands?
      parser.advance
      yield current_command(parser)
    end
  end

  def current_command(parser)
    case parser.command_type
    when Parser::A_COMMAND
      Command::Addressing.new(parser.symbol)
    when Parser::C_COMMAND
      Command::Compute.new(parser.dest, parser.comp, parser.jump)
    when Parser::L_COMMAND
      Command::Label.new(parser.symbol)
    end
  end
end

module Symbols
  module_function

  def build_table
    SymbolTable.new.tap do |symbol_table|
      # TODO add predefined symbols
      # TODO add labels
    end
  end
end

module Command
  RADIX = 10

  Addressing = Struct.new(:symbol) do
    def each_instruction(symbol_table)
      yield Instruction::Addressing.new(value(symbol_table))
    end

    private

    def value(symbol_table)
      if numeric?
        symbol.to_i(RADIX)
      else
        # TODO handle variables
        raise "unknown symbol “#{symbol}”" unless symbol_table.contains?(symbol)
        symbol_table.get_address(symbol)
      end
    end

    def numeric?
      Integer(symbol, RADIX) rescue false
    end
  end

  Compute = Struct.new(:dest, :comp, :jump) do
    def each_instruction(symbol_table)
      yield Instruction::Compute.new(dest, comp, jump)
    end
  end

  Label = Struct.new(:symbol) do
    def each_instruction(symbol_table)
      # do nothing
    end
  end
end

module Instruction
  BIT_COUNT = 16
  ADDRESSING_BIT = '0'
  COMPUTE_BIT = '1'

  Addressing = Struct.new(:value) do
    def assemble
      value.to_s(2).rjust(BIT_COUNT, ADDRESSING_BIT)
    end
  end

  Compute = Struct.new(:dest, :comp, :jump) do
    def assemble
      [Code.comp(comp), Code.dest(dest), Code.jump(jump)].join.rjust(BIT_COUNT, COMPUTE_BIT)
    end
  end
end

Program.new(ARGF.read).each_instruction do |instruction|
  puts instruction.assemble
end
